from autogen import ConversableAgent
import os

"""
This file extends the AutoGen framework to enable saving replies generated by 
the LLM directly to a specified Python file. It is based on `decorators` and does
not modify the AutoGen source-code directly.
"""


def save_reply_decorator(func):
    """
    Decorator to persist replies to a specified file.
    It wraps around `generate_reply` to save generated replies post-generation.
    """
    def wrapper(self, *args, **kwargs):
        # Generate the reply using the original function
        reply = func(self, *args, **kwargs)

        # Save the generated reply if a save path is specified
        if self.reply_save_path and reply:
            self.save_reply_custom(reply)

        return reply

    return wrapper


class CustomConversableAgent(ConversableAgent):
    def __init__(self, *args, reply_save_path="", **kwargs):
        """
        Initializes the CustomConversableAgent with an optional path for saving replies.

        :param reply_save_path: Path to the file where generated replies will be saved.
        """
        super().__init__(*args, **kwargs)
        self.reply_save_path = reply_save_path

    def save_reply_custom(self, reply):
        """
        Extracts Python code from the reply and saves it to the specified file.

        :param reply: The generated reply containing Python code.
        """
        directory = os.path.dirname(self.reply_save_path)
        if not os.path.exists(directory):
            os.makedirs(directory)

        # Initialize `content` to None to capture potential Python code blocks.
        content = None

        # Check for the "```python" tag to identify where Python code starts.
        if "```python" in reply:
            start = reply.find("```python") + len("```python")
            # Locate the next closing "```" tag to determine where the code block ends.
            end = reply.find("```", start)

            # If a closing tag is found, extract the Python code section.
            if end != -1:
                content = reply[start:end].strip()

        # Save the extracted Python code to the specified file if available.
        if content:
            with open(self.reply_save_path, 'w') as file:
                file.write(content)

    @save_reply_decorator
    def generate_reply(self, *args, **kwargs):
        """
        Generates a reply and saves it if a valid path is set.

        :return: The generated reply.
        """
        return super().generate_reply(*args, **kwargs)
